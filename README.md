
# Table of Contents

1.  [Installation](#orge8d4b4e)
2.  [Usage](#org046d0b1)



<a id="orge8d4b4e"></a>

# Installation

To install this Package clone this repository to a directory of your choice:

    mkdir ~/somedir
    cd ~/somedir
    git clone https://github.com/RafaelDavidMohr/SignatureGB.jl

Then start a Julia REPL, press `]` to enter the package manager, and type

    (@v1.7) pkg> add ~/somedir/SignatureGB.jl/

Now you should be able to start using this Package:

    julia> using SignatureGB


<a id="org046d0b1"></a>

# Usage

This package exports the three function `sgb`, `f5sat` and `nondegen_part`:

-   `sgb` implements the rewrite framework to compute signature Gröbner bases as presented in this [survey paper](https://arxiv.org/abs/1404.1774). This function takes as input a variable of type `Vector{P}`  where `P` is a type representing polynomials inheriting from `AbstractAlgebra.MPolyElem`. For instance, both the polynomial data types from the packages `Singular.jl` and `Oscar` can be used. This vector is then used as the initial set of generators to compute a signature Gröbner basis for. Note that the behaviour of such a computation heavily depends on both the elements of this `Vector` and also the order of it. It may be advisable to sort this `Vector` by degree for example.
-   `f5sat` is a saturation algorithm based on the F5 algorithm, which is a special signature based Gröbner basis algorithm. It takes as input a variable `I` of type `Vector{P}`, where `P` is as above, and an element `f` of type `P`. It then computes a Gröbner basis of the saturation by `f` of the ideal generated by `I`. This saturation strategy is optimal if `I` is known to be a Gröbner basis. In this case you should call this function as `f5sat(I, p, start_gen = length(I))`.
-   `nondegen_part` computes an ideal `J` representing the union of the components of codimension c of an algebraic set cut out by c polynomials where c is less or equal than the number of variables of the underlying polynomial ring. The underlying algorithm is presented in [this paper](https://arxiv.org/abs/2202.13784). It also takes as input a variable of type `Vector{P}` where `P` is as above. It outputs a Gröbner basis of `J`.

For all three function, the coefficient field of the underlying polynomial ring has to be a finite field of characteristic less than 2<sup>31</sup>.

    using SignatureGB
    using Singular
    
    R, (x, y, z) = PolynomialRing(Fp(65521), ["x", "y", "z"])
    
    F = [x*y, x*z]
    sgb(F)
    f5sat(F, x)
    nondegen_part(F)

Additionally, the following optional arguments might be of interest to most users. For an explanation of their mathematical meaning, see also the above mentioned [survey paper](https://arxiv.org/abs/1404.1774).

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Argument</th>
<th scope="col" class="org-left">Explanation</th>
<th scope="col" class="org-left">Default</th>
<th scope="col" class="org-left">Options</th>
</tr>
</thead>

<tbody>
<tr>
<td class="org-left"><code>verbose</code></td>
<td class="org-left">Whether to print various logging information during and after the computation, i.e. details on how the Gröbner basis computation behaved. No information is printed when <code>verbose=0</code>.</td>
<td class="org-left"><code>0</code></td>
<td class="org-left"><code>0</code>, <code>1</code> or <code>2</code></td>
</tr>


<tr>
<td class="org-left"><code>mon_order</code></td>
<td class="org-left">The monomial order in the GB computation.</td>
<td class="org-left"><code>:GREVLEX</code></td>
<td class="org-left">Currently only grevlex (degree reverse lexicographical) supported</td>
</tr>


<tr>
<td class="org-left"><code>mod_order</code></td>
<td class="org-left">The module monomial order used for the signatures. <code>f5sat</code> and <code>nondegen_part</code> always use <code>:POT</code>.</td>
<td class="org-left"><code>:POT</code></td>
<td class="org-left"><code>:POT</code>, <code>:DPOT</code>, <code>:TOP</code>, <code>:SCHREY</code></td>
</tr>


<tr>
<td class="org-left"><code>f5c</code></td>
<td class="org-left">Whether to use the f5c optimization ("F5 computing with reduced Gröbner bases"). This has to be combined with <code>:POT</code>.</td>
<td class="org-left"><code>false</code></td>
<td class="org-left"><code>true</code> or <code>false</code></td>
</tr>


<tr>
<td class="org-left"><code>all_koszul</code></td>
<td class="org-left">Whether to check the pair signatures for divisibility against all Koszul syzygy signatures. Disabling this may yield a speedup for some module orders. This is always enabled in <code>f5sat</code> and <code>nondegen_part</code>.</td>
<td class="org-left"><code>false</code></td>
<td class="org-left"><code>true</code> or <code>false</code></td>
</tr>
</tbody>
</table>

